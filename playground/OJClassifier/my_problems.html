<html>
<head>
<title>Online Judge Solution Classifier - Him0727 .NET</title>
<meta charset="utf-8">
<meta name="author" content="CHAN TAK HIM, him0727">
<meta name="description" content="him0727's online judge solutions classifier" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="favicon.ico" type="image/x-icon" rel="shortcut icon" />
<style>
  a {
    color: #0174DF;
    text-decoration: none;
  }
  body {
    padding: 0;
    margin: 0;
    font-family: "Trebuchet MS";
  }
  hr {
    border: 0;
    background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
    height: 1px;
    margin: 30px 0 30px 0;
  }
  h2 {
    text-align: center;
    margin: 5px 0 5px 0;
  }
  h3 {
    margin: 10px 0 5px 0;
  }
  .content {
    padding: 10px;
    overflow: hidden;
  }
  .menu-this, .menu {
    font-weight: bold;
    font-size: 15px;
    padding: 5px;
    display: inline-block;
  }
  .menu-this {
    border: 2px #D8D8D8 inset;
    background-color: rgba(238, 238, 238, 0.3);
    color: #D8D8D8;
    text-decoration: underline;
  }
  .menu {
    border: 2px #D8D8D8 solid;
    background-color: rgba(238, 238, 238, 0.7);
  }
  .menu a {
    color: #04177C;
  }
  .menu:hover {
    cursor: hand;
  }
  .constraint {
    font-size: 9px;
    text-align: center;
    margin: 0 0 5px 0;
    line-height: 10px;
  }
</style>
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
</head>
<body>
<div class="content" style="background-color: #04177C; color: #ffffff;">
<div style="float: left;">
<h2 style="margin: 3px;">Him0727's Online Judge Solutions Classifier</h2>
</div>
<div style="float: right;">
<span class="menu-this">Problems created by me</span>
<span class="menu"><a href="index.html">My solutions to others' problems</a></span>
</div>
</div>
<div class="content" style="background-color: #EFF1FA;">
  <span style="color: red;">I am a problem setter on SPOJ. This page contains the links of problem statements and solutions to the problems created by me. If you have not seen it yet, welcome to solve it. If you feel stuck, try to read the solution and implement it. I look forward to your better solution.</span>
</div>
<div class="content">
  <h2>PRIPYAT - Pripyat</h2>
  <div class="constraint">
    Time: 5s per test file<br />
    Source: 5000B<br />
    Memory: 1536MB<br />
    Languages: ALL<br />
    Problem statement: <a href="http://www.spoj.com/problems/PRIPYAT/" target="_blank">Link</a>
  </div>
  I wrote this problem to commemorate the 32-nd anniversary of the Chernobyl nuclear disaster, and my second visit to Chernobyl in May, 2018 since August, 2016. Okay, let's start the solution.
  <h3>Approach 1: Dynamic programming and bitmasking</h3>
  Firstly, we have to select some places to visit so that the total EXC is maximized and the VT and RL are less than or equal to the given limit. This is a classical 3D 0/1 knapsack problem, so we can use dynamic programming (DP). We define a function f1(x, y, z) as the maximum EXC we can get, in which we consider places from the first place to x-th place, by not exceeding y unit of VT and z amount of TL. Obviously, when any of x, y, z is 0, f1(x, y, z) is 0. For x &ge; 1, we only consider x-th place when VT[x] &le; y and RL[x] &le; z, hence we get f1(x, y, z) = max(f1(x - 1, y, z), f1(x - 1, y - VT[x], z - RL[x]) + EXC[x]). Otherwises, it is impossible to accept VT[x], RK[x], or both, so we don't visit x-th place and f1(x, y, z) = f1(x - 1, y, z). Now, f1(N, MVT, TRL) is the maximum EXC we can get. We can know what places are selected by iterating over all f1's results backwards. Since the f1(x, y, z) is in increasing order, we start from f1(N, MVT, TRL), x-th place is selected when f1(x, y, z) &gt; f1(x - 1, y, z). After each selection, we set y to y - VT[x] and z to z - RL[x]. The iteration stops when any x, y, z is 0, which means it is impossible for all remaining places to meet all given limits. Note that RL is a set of real numbers with at most 2 digits after the decimal point, we can multiply RL and TRL by 100 so that the whole part can be solved by integer linear programming in O(N * MVT * TRL * 100).<br /><br />
  Now we know what places are selected, and have to find out the shortest distance from the starting point to visit all selected places without duplicate visit. The first step is to set all unselected places in the matrix to a barrier. Assume that K places are selected, as units are in equal distance, we will do a breadth first search (BFS) K + 1 times (because the starting point is included) at the location of i-th selected place to find out the shortest distance from i-th place to other places. That is, results are stored in DIST[K][R][C]. Note that when performing BFS, we must not put barriers and selected places into the queue (but we do calculate the shortest distance of that cell) because we are not allowed to visit the selected places twice or more. So, if the target is blocked, the distance will be INF (number larger than possible answer). This pre-calculation done in (R * C * (K + 1)) gives us important information to optimize the result.<br /><br />
  Then, we can enumerate all possibilities with the help of DP and bitmasking. Integer can be represented by a set of bits which is either 1 or 0, which can be used in representing the state of a place. From the right, if the i-th bit is set, the i-th place is visited. Therefore, the bound of masks is 2<sup>K + 1</sup> - 1. We again define a function f2(x, y) as the shortest distance from x-th place to visit all the selected places by already visiting y in mask places. So, we only consider those places where haven't been to. From that, the DP state transition is as follows: for each place, if (y & (1 &lt;&lt; i)) is 0, f2(x, y) = min(f2(i, (y | (1 &lt;&lt; i))) + DIST[x][R<sub>i</sub>][C<sub>i</sub>]). To avoid overlapping computation, in every recursion we can return the result immediately if f2(i, (y | (1 &lt;&lt; i)) is memoized already. Also, one possible sequence will stop calling f2 if all bits are set, which means all places are visited and equal to bound. At first, suppose we have an array G of K + 1 elements, where G[0] is the location of the starting point, following K G[i] is the location of each selected place. We will start from the starting point and none of the place is visited except the starting point, so we initially call f2(0, 1). Remember that if one point is inaccessible from x-th place, the distance matrix of that cell is INF. It means that if the result obtained by f2(0, 1) &ge; INF, it is impossible to visit all selected places without duplicate visit from the starting point.<br /><br />
  To sum up, this problem is NP-hard, there is no very efficient algorithm to get the exact result. That's why the time limit is greatly longer than other problems' and the input constraints are quite small. With the help of DP and bitmasking, the time and space complexity is reduced, and the problem can still be solved accurately in reasonable time, which is O(N * MVT * TRL * 100 + R * C * (K + 1) + K<sup>2</sup> * 2<sup>K</sup>).<br />
  Solution: <a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/PRIPYAT.cpp" target="_blank">Link</a>
  <hr />
  
  <h2>TRIBT - Triangle in Binary Tree</h2>
  <div class="constraint">
    Time: 0.5s per test file<br />
    Source: 5000B<br />
    Memory: 1536MB<br />
    Languages: ALL<br />
    Problem statement: <a href="http://www.spoj.com/problems/TRIBT/" target="_blank">Link</a>
  </div>
  The binary tree constructed from parent array may be either balanced, unbalanced, complete or full, especially for the unbalanced one, there is no regular pattern to count the potential isosceles triangles (PIT). But this is quite easy to see the logic. 
  <h3>Approach 1: Depth first search (DFS)</h3>
  Two paths starting from a parent node or root form a triangle. To meet the isosceles property, two paths must have the same length, therefore the number of PIT formed by these two paths is simply min(TO_CHILD_PATH<sub>left</sub>, TO_CHILD_PATH<sub>right</sub>). Please note that we must also check the min(TO_PARENT_PATH<sub>left</sub>, TO_CHILD_PATH<sub>right</sub>) and min(TO_PARENT_PATH<sub>right</sub>, TO_CHILD_PATH<sub>left</sub>) because the triangle can be in any direction. But in binary tree, it can only go left, go right or be upward. Therefore, the answer is the sum of these three values. To implement this, we can do a recursive DFS from the root. <br /><br />
  LT[parent] stores the left child of parent and RT[parent] stores the right child, if any, otherwises its value is -1. LT_CHILD[parent] and RT_CHILD[parent] store the length of path from the parent towards its left and right leaf, while LT_PARENT[parent] and RT_PARENT[parent] store the length of path from the parent to its parent. If one way is unconnected, the corresponding value is 0 (Like the root has no parent and leaf has no child). Our DFS firstly checks if the parent (initially it is root) has left child. If yes, it sets LT_PARENT[LT[parent]] to LT_PARENT[parent] + 1, and call itself from LT[parent], and then set LT_CHILD[parent] to LT_CHILD[LT[parent]] + 1. Do the same for the right child. We then have the three required values and simply add them to the answer.<br />
  Solution: <a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TRIBT.cpp" target="_blank">Link</a>
  <hr />
  
  <h2>SMTOILET - Smelly Toilets</h2>
  <div class="constraint">
    Time: 0.1s per test file<br />
    Source: 5000B<br />
    Memory: 1536MB<br />
    Languages: ALL<br />
    Problem statement: <a href="http://www.spoj.com/problems/SMTOILET/" target="_blank">Link</a>
  </div>
  M is so large while N is so small that it is impossible to solve the problem by brute force. I used this approach to verify my solution and it spent at least 10 hours to solve just one test case in a test file. Note that the amount of released odors is accumulated with the growth of time, so it will never be decreased. Due to the sorted property in nature, we do not have to calculate the amount from the very beginning at time 0 until it minimizes the diference between it and M.
  <h3>Approach 1: Binary search</h3>
  To pass the time limit, we set the lower bound to 1 and upper bound to M / toilets[0], because the first toilet will release smells immediately and the longest time will be M / toilets[0]. Let the middle LOW + (HIGH - LOW) / 2 be MID (using (HIGH + LOW) / 2 causes overflow), we can calculate the amount of odors at MID by &sum;<sub>i=0</sub><sup>N - 1</sup>toilets[i] * MID - toilets[i] * i in O(N), if MID &lt; N - 1, break the loop when i + 1 &gt; MID. If the amount at MID &ge; M then HIGH = MID, else LOW = MID + 1, until LOW &ge; HIGH. Since the last resultant amount at HIGH is always &ge; M, we should always check if M - (amount at HIGH - 1) &lt; amount at HIGH - M, and then choose the one with smaller difference. The algorithm to find the time works in O(HIGH * logN).<br /><br />
  For the cubicle selection, the main idea is to find the maximum of consecutive available cubicles. As the answer should be as middle in the chosen range as possible, but it is affected by which side the entrance E is located at if the length of range is even. We can split the string by the entrance, counting the maximum of consecutive available cubicles on the left from 0 to E - 1, and right part from len(S) - 1 to E + 1, respectively. As they iterate towards each other, it is easy to find the middle by i - ceil(TEMPSCORE<sub>left</sub> / 2.0) and j + ceil(TEMPSCORE<sub>right</sub> / 2.0).<br />
  Solution: <a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/SMTOILET.cpp" target="_blank">Link</a>
  <h3>Approach 2: Prefix sum</h3>
  Actually (toilets[0] + toilets[1] + ... + toilets[N - 1]) - (toilets[1] * 1 + toilets[2] * 2 + ... + toilets[N - 1] * N - 1) can be obtained using prefix sum and prefix sum of prefix sum. Let 1 &le; i &le; N, then PSUM<sub>i</sub> = &sum;<sub>j=0</sub><sup>i</sup>toilets[j], and PPSUM<sub>i</sub> = &sum;<sub>j=0</sub><sup>i</sup>PSUM[j]. After repeating N times, if PPSUM is still &le; M, we can find the remaining time to minimze the difference between the amount of odors and M by PPSUM = PPSUM<sub>N</sub> + (M - PPSUM<sub>N</sub>) / PSUM<sub>N</sub> and the answer is (M - PPSUM<sub>N</sub>) / PSUM + N. Again, since the answer surly &le; M, we have to calculate the next higher PPSUM and new candidate answer and choose the one with smaller difference.
  <hr />
  
  <h2>MAPEXC - Map Exploration Cost</h2>
  <div class="constraint">
    Time: 0.2s per test file<br />
    Source: 5000B<br />
    Memory: 1536MB<br />
    Languages: ALL<br />
    Problem statement: <a href="http://www.spoj.com/problems/MAPEXC/" target="_blank">Link</a>
  </div>
  This is a graph problem. Actually, we can treat cost as distance, so our main task is to caculate the cost matrix for the given map. Once we know the shortest distances from S to all other cells (it seems Dijkstra Algorithm is useful here), we can answer the first question of the problem and generate the new map for the second question. If you are careful enough, you will find a big hint mentioned in the problem statement: only from '.' to '.' will increase no cost. Now, we get two conditions for every move: 1. Cost remains unchanged, or 2. Cost + 1.
  <h3>Approach 1: Breadth first search (BFS)</h3>
  We need a cost matrix filled with -1 and to do a BFS from S in four directions in O(N * M). Let the front of the queue be P, check if the new adjacent cell (C) is within the map area. If yes, we have to check the map symbol of P and C. If graph[C<sub>i</sub>][C<sub>j</sub>] and graph[P<sub>i</sub>][P<sub>j</sub>] are both '.', we will enter condition 1, else condition 2.<br /><br />
  Condition 1: cost[C<sub>i</sub>][C<sub>j</sub>] = -1 means we have not visited C yet, or cost[C<sub>i</sub>][C<sub>j</sub>] &gt; cost[P<sub>i</sub>][P<sub>j</sub>] means we have shorter distance from S to C. In these cases, cost[C<sub>i</sub>][C<sub>j</sub>] = cost[P<sub>i</sub>][P<sub>j</sub>].<br />Condition 2: cost[C<sub>i</sub>][C<sub>j</sub>] = -1, or cost[C<sub>i</sub>][C<sub>j</sub>] &gt; cost[P<sub>i</sub>][P<sub>j</sub>] + 1 means the shortest distance from S to C will be cost[P<sub>i</sub>][P<sub>j</sub>] + 1. In these cases, cost[C<sub>i</sub>][C<sub>j</sub>] = cost[P<sub>i</sub>][P<sub>j</sub>] + 1.<br /><br />
  Then, we push C into the queue, keep iterating until it is empty. Finally, all cells are visited and we get the cost matrix, telling us the shortest distances from S to other cells. We can now just check if cost[F<sub>i</sub>][F<sub>j</sub>] &le; D to answer the first question. For the second question, loop through the cost matrix, if current position is S or F, output the corresponding character. If not, check if cost[i][j] &le; cost[F<sub>i</sub>][F<sub>j</sub>], if yes, output '.', else '#'.<br />
  Solution: <a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MAPEXC_1.cpp" target="_blank">Link</a>
  <h3>Approach 2: Combination of BFS and DFS (Depth first search)</h3>
  If you love typing, choose this approach. The procedure is BFS - DFS - BFS. Firstly, do a BFS from S in four directions, without comparing the map symbol of the front of the queue with the adjacent cell. But we have to check if the new cell's symbol is '.', and record the position E of the first one, in order to know the shortest distance from S to the nearest tunnel cell and its position. This gives us the shortest distances from S to other cells in cost1[N][M], assuming there is no empty tunnel in the given map. If there are, now we can do a DFS from E to fill the whole tunnel and find the edge of it, that is, at least one edge of tunnel cell is not connected with another tunnel cell. After that, do a BFS again. This time, we do it for a polygon (as we know the edge of tunnel) with initial cost cost1[E<sub>i</sub>][E<sub>j</sub>], rather than a point. This gives us the shortest distances from the edge of tunnel to other cells plus its initial cost in cost2[N][M]. If we merge cost1[N][M] and cost2[N][M] by choosing min(cost1[i][j], cost2[i][j]), we will obtain the correct cost matrix.<br />
  Solution: <a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MAPEXC_2.cpp" target="_blank">Link</a>
  <hr />
  
  <h2>TRFPLN - Traffic Planning</h2>
  <div class="constraint">
    Time: 0.04s per test file<br />
    Source: 5000B<br />
    Memory: 1536MB<br />
    Languages: ALL<br />
    Problem statement: <a href="http://www.spoj.com/problems/TRFPLN/" target="_blank">Link</a>
  </div>
  The road network is in grid pattern and the traffic police can only move horizontally and vertically. These observations imply that we are required to calculate the 3D manhattan distance using formula |X<sub>i</sub> - X<sub>j</sub>| + |Y<sub>i</sub> - Y<sub>j</sub>| + |Z<sub>i</sub> - Z<sub>j</sub>|, between each intersection and all other intersections. And the one that has the smallest sum of distances is the answer. Brute-force is the easiest way to solve and implement, but O(N<sup>2</sup>) is likely to fail the time limit (0.04s). So we need a better strategy.
  <h3>Approach 1: Sorting and prefix sum</h3>
  For manhattan distance, we can consider each dimension separately. Firstly, we sort X, Y, Z ascendingly with its original ID in three separate arrays, respectively, in O(3 * N log N). Then, we calculate the prefix sum of X, Y, Z respectively, using three sorted arrays. The prefix sum for a particular dimension D (X / Y / Z) at j-th point is: prefix<sub>D</sub>[0] = 0 and &sum;<sub>i=0</sub><sup>j</sup>D[i].val. That is, prefix[j] = prefix[j - 1] + D[j - 1].val. With the help of prefix sum, we can calculate the sum of distances to other points for a point in each dimension in the sorted dimension value order. We have to make use of the original ID of the current sorted point. For a particular i-th point, the idea is to find the left part sum (smaller than D<sub>i</sub>) and the right part sum (larger than Z<sub>i</sub>), the derived relation is DIST<sub>D</sub>[D[i].id] = i * D[i].val - prefix<sub>D</sub>[i] + prefix<sub>D</sub>[N] - prefix<sub>D</sub>[i + 1] - (N - i - 1) * prefix<sub>D</sub>[i].val, 0 &le; i &le; N - 1. The last step is simply to use linear scan to find the index i that minimizes prefix<sub>X</sub>[i] + prefix<sub>Y</sub>[i] + prefix<sub>Z</sub>[i] in O(N). The overall time complexity is O(N * logN).<br />
  Solution: <a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TRFPLN.cpp" target="_blank">Link</a>

  <br /><br />
  <div style="text-align: center;">&copy; 2018 <a href="https://him0727.github.io/" target="_blank">HIM0727 .NET</a></div>
</div>
</body>
</html>