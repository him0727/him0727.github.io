<html>
<head>
<title>My problems :: Algohol - Him0727 .NET</title>
<meta charset="utf-8">
<meta name="author" content="CHAN TAK HIM, him0727">
<meta name="description" content="Aloghol, a website about data structure and algorithm, powered by HIM0727 .NET" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="favicon.ico" type="image/x-icon" rel="shortcut icon" />
<link rel="stylesheet" href="styles/global.css">
<link rel="stylesheet" href="styles/probs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5Z8HTHXXZ4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-5Z8HTHXXZ4');
</script>
</head>
<body>
  <nav class="content">
    <span id="nav-left"></span>
    <span id="nav-right"></span>
  </nav>
  <div class="content" style="background-color: #EFF1FA;">
    <span style="color: #36AD16;">
      <svg class="bi bi-emoji-laughing" style="margin-top: 10px;" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
        <path fill-rule="evenodd" d="M12.331 9.5a1 1 0 0 1 0 1A4.998 4.998 0 0 1 8 13a4.998 4.998 0 0 1-4.33-2.5A1 1 0 0 1 4.535 9h6.93a1 1 0 0 1 .866.5z"/>
        <path d="M7 6.5c0 .828-.448 0-1 0s-1 .828-1 0S5.448 5 6 5s1 .672 1 1.5zm4 0c0 .828-.448 0-1 0s-1 .828-1 0S9.448 5 10 5s1 .672 1 1.5z"/>
      </svg>
       - I am pleased to announce that my problem "LNTILING - Long Tiling" was selected as one of the ten problems in <a href="https://www.bubblecup.org/CompetitorsCorner/Problems" target="_blank">Round 2, Bubble Cup 13 (2020)</a>.
    </span>
  </div>
  <div class="content">
    <div id="left-menu" style="text-align: left">
      <ul>
        <li>TLPNGEM2 - Teleporters and Gems II</li>
        <li>ACRYM - Acronym</li>
        <li>KTRANS - K-transfer journey</li>
        <li>MACHCOOL2 - Machine Cooling II</li>
        <li>MACHCOOL - Machine Cooling</li>
        <li>TLPNGEM - Teleporters and Gems</li>
        <li>LNTILING - Long Tiling</li>
        <li>GIFTARNG - Gift Arrangement</li>
        <!--<li>PSHAPE - Plane Shapes Formation</li>-->
        <!--<li>PRIPYAT - Pripyat</li>-->
        <li>TRIBT - Triangle in Binary Tree</li>
        <li>SMTOILET - Smelly Toilets</li>
        <li>MAPEXC - Map Exploration Cost</li>
        <li>TRFPLN - Traffic Planning</li>
      </ul>
    </div>
    <div id="right-content"></div>
    <div style="display: none;">
      <div id="TLPNGEM2">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/TLPNGEM2/" target="_blank">Link</a> | 
          Time: 0.5s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2022-02-12<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Ad-hoc</span><span class="tag">Basic Math</span><span class="tag">Geometry</span>
        </div>
        <hr />
        Welcome to my first interactive problem! The constraints are not tight, we can actually guess the answer in just three tries.
        <h3>Approach 1: Elementary algebra (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TLPNGEM2_1.cpp" target="_blank">Solution Link</a>)</h3>
        In this problem, 10<sup>9</sup> by 10<sup>9</sup> unit is the size of a quadrant. To make our answer relative to origin (0, 0), we should start from two rightmost coordinates (10<sup>9</sup>, 10<sup>9</sup>) and (10<sup>9</sup>, -10<sup>9</sup>). Let <strong>D1</strong> and <strong>D2</strong> be the manhattan distances from these coordinates to our target <strong>T</strong>, where D1 + D2 &ge; 10<sup>9</sup> * 2. By calculating D1 + D2 - 10<sup>9</sup> * 2, we know the x-axis distance from the rightmost boundary to the x-coordinate of T, then we get the x-coordinate of T by subtracting that value from 10<sup>9</sup>. Hence, X = 10<sup>9</sup> - (D1 + D2 - 10<sup>9</sup> * 2) / 2 = 10<sup>9</sup> * 2 - (D1 + D2) / 2. Once we know X, we can substitute X into D1 = |10<sup>9</sup> - X| + |10<sup>9</sup> - Y|, thus Y = 10<sup>9</sup> * 2 - X - D1. We are able to guess T in two guesses, the last guess is for receiving a verdict. This is a constant time solution running in O(1).
        <h3>Approach 2: Line-line intersection (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TLPNGEM2_2.cpp" target="_blank">Solution Link</a>)</h3>
        Same as above, we will be guessing the upper right corner and lower right corner to obtain <strong>D1</strong> and <strong>D2</strong>. Every coordinate that is D1 units away from (10<sup>9</sup>, 10<sup>9</sup>) is a potential target. Similarily, every coordinate that is D2 units away from (10<sup>9</sup>, -10<sup>9</sup>) is a potential target. Since in this problem we are calculating manhattan distance, those potential coordinates originated from D1 and D2 will form two straight lines respectively. The intersection point of these two lines is the target. We can simply pick any two points on each of the two lines and find the intersection. Now it becomes a famous problem with a well kwown solution using determinants (read <a href="https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line" target="_blank">Line-line intersection page on Wikipedia</a>). Although this solution requires a slightly heavy implementation and computation, the time complexity is still O(1).
      </div>
      <div id="ACRYM">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/ACRYM/" target="_blank">Link</a> | 
          Time: 0.8s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2020-05-14<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Combinatorics</span><span class="tag">String</span><span class="tag">Prefix & Suffix</span><span class="tag">Subsequence</span>
        </div>
        <hr />
        By drawing a tree diagram for every possible combination with a dummy root, we will find there are many overlapping subpaths. The performance can be improved by bottom-up dynamic programming.
        <h3>Approach 1: Dynamic Programming (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/ACRYM.cpp" target="_blank">Solution Link</a>)</h3>
        For a particular i-th word, let <strong>f[j]</strong> and <strong>f'[j]</strong> be the number of possible combinations of making S[0 ... j] using the prefixes from W[0] to W[i - 1], and from W[0] to W[i], respectively. For W[0], f[1 ... k] = 1 where k is the length of longest common prefix with S. Now consider the following transition states for W[i] where i &gt; 0:
        <ul>
          <li><strong>For conjuction or adposition, f' remains unchanged</strong><br />
          If W[i] is conjuction or adposition, we can ignore it, hence f'[j] = f[j], otherwise f'[j] = 0.<br />
          </li>
          <li><strong>Combine W[i]'s prefixes with S's prefixes</strong><br />
          Let <strong>P<sub>W</sub></strong> and <strong>P<sub>S</sub></strong> be the length of current prefix of W[i] and S respectively, where 1 &le; P<sub>W</sub> &le; min(|W[i]|, |S|) and P<sub>W</sub> &lt; P<sub>S</sub> &le; |S|. We want to satisfy two conditions: First, W[i][0 ... P<sub>W</sub> - 1] is a suffix of S[0 ... P<sub>S</sub> - 1]. Second, S[0 ... P<sub>S</sub> - P<sub>W</sub> - 1] is contiguous considering all preceding words, that is, f[P<sub>S</sub> - P<sub>W</sub> - 1] &gt; 0. If all good, f'[P<sub>S</sub>] = f'[P<sub>S</sub>] + f[P<sub>S</sub> - P<sub>W</sub> - 1]. Note that if f'[j] = 0 for every j, the result is no longer contiguous so we can immediately return 0.
          </li>
          <li><strong>Swap f[j] with f'[j]</strong><br />
          Make use of f'[j] to compute the next f'[j], so f[j] = f'[j]
          </li>
        </ul>
        Our final answer is f[|S|]. Everything is bounded by |S|, so the time complexity is O(N * |S|<sup>2</sup>). Another way to think the problem: for each word, it forms a set with |W[i]| elements, containing all prefixes of W[i] (also empty string if it is conjunction or adposition), where its value is the prefix length. We have N sets and a bag with |S| capacity, we want to select one element from each set, such that the bag value is exactly |S| while satisfying the constraint that the selected element must be part of the suffix of current S. This is a variant of multiple-choice knapsack problem.
      </div>
      <div id="KTRANS">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/KTRANS/" target="_blank">Link</a> | 
          Time: 0.4s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2019-11-02<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Shortest Path</span>
        </div>
        <hr />
        We can view the shortest travel time as the shortest weighted path. Then this problem is clearly all-pairs constrained shortest path problem, the true way to go is to use a variant of Floyd-Warshall algorithm.
        <h3>Approach 1: Run Floyd-Warshall algorithm K times (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/KTRANS.cpp" target="_blank">Solution Link</a>)</h3>
        Given a directed graph <strong>G = (V, E)</strong> with weight W[i] for E[i] and the second constraint L[i] for V[i], where V donates cities, E donates flights and W donates travel time. Note that one of the constraints in this problem is that the amount of incoming accumulate flow for each directly connected pair of nodes is restricted, thus the following shortest path property is not necessarily true: A subpath of a shortest path is a shortest path, hence the resulting path(u, v) doesn't always be path(u, k) + path(k, v). Instead we will find the shortest path by doing K relexations for each vertex with a condition check on L[i].<br /><br />
        Define two distance matrices <strong>D'</strong> as the results of length K - 1 and <strong>D</strong> as the results of length K. We will be finding the shortest path for every (U, V) with length from 1 to K incrementally. In each relaxation, for each (U, V), we treat U[i] as an intermediate vertex and test whether the shortest travel time from a particular city <strong>T</strong> to V[i] can be improved by passing through path(T, U[i], V[i]) by satisfying the constraint D'[T][U[i]] &le; L(U[i], V[i]). Hence, if there is a path from T to V[i], D[T][V[i]] = min(D'[T][U[i]] + W[i]). The next relaxation needs to make use of the current results, thus D = D'. This solution requires K relaxations for each (U, V), hence can be run in O(K * |E| * |V|), around 6002500 iterations in the worse case.
      </div>
      <div id="MACHCOOL2">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/MACHCOOL2/" target="_blank">Link</a> | 
          Time: 0.5s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2019-05-29<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Graph</span><span class="tag">Greedy</span><span class="tag">Heap</span><span class="tag">Matching</span><span class="tag">Binary Search</span><span class="tag">Depth-first Search</span>
        </div>
        <hr />
        The requirements of this problem are similar to MACHCOOL, except for the duration of tasks and the number of machines. We have many ways to solve this problem.
        <h3>Approach 1: Min heap (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL2_1.cpp" target="_blank">Solution Link</a>)</h3>
        We are only interested in max(D[i][j]) for a particular i-th task because T[i] must wait for the preceding task to complete before it can proceed. Sort T by start time and end time ascendingly. Let <strong>M</strong> be the minimum number of machines we need. We want one machine to deal with as many tasks as possible, so we must assign T[i] to a machine as early as possible once its start time &ge; the end time of the latest task assigned to that machine. Otherwise, we need a new machine to hold that task. For T[i], we need to get the earliest end time among T[0] to T[i - 1] using min heap. If the start time of T[i] &ge; heap's root, it means T[i] can be held by existing machines, then we continue to perform the check in the heap until T[i] has a conflict with it. Finally, the remaining elements of the heap are the end time of tasks which we need a new machine to handle. Thus, M is the heap size.<br /><br />
        To distribute them optimally, the idea is similar to the greedy approach mentioned in MACHCOOL. We consecutively distribute M machines as early as possible by pushing the first M tasks into an empty min heap. For the remaining N - M tasks, our goal is to maximize the gap between the start time of T[i] and the end time of the latest task assigned to any machine. Note that the heap's root is already the earliest end time of the task already assigned, hence the answer is min(start time of T[i] - heap's root) for each remaining task. The overall time complexity is O(N * logN). 
        <h3>Approach 2: Line sweep with binary search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL2_2.cpp" target="_blank">Solution Link</a>)</h3>
        Again, we need to know <strong>M</strong>, which is the minimum number of machines needed to handle all tasks. We use the same greedy insight with line sweep algorithm. Donate <strong>f(C)</strong> as M with C cooling time for each machine. This time We are going to flatten T into two pairs (start time, 1) and (start time + max(D[i][j]) + C, -1) and sort them ascendingly. By loop through N * 2 records, we can recognize if it is the start time or end time by the second element of the pair. If the value is 1, we need a new machine to hold that task, otherwise an existing machine is released and can be used by another task. Hence f(C) = max(&sum;<sub>i=0</sub><sup>j</sup>record[i]'s second element), where 0 &le; j &lt; N * 2, and f(0) gives us the minimum of machines we need. Let's do binary search on C. Let <strong>L</strong> and <strong>R</strong> be the search range, where L = 0 and R = 86400. For each median <strong>MID</strong>, if M &ge; f(MID), it is a valid answer because M machines are enough to handle all the tasks with MID cooling time, then we can look for a larger guess. Otherwise, we need to decrease the cooling time. This solution has the same time complexity as before.
        <h3>Approach 3: Maximum bipartite matching (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL2_3.cpp" target="_blank">Solution Link</a>)</h3>
        This problem can be modelled as a graph problem. Let <strong>G = (V, E)</strong> be a directed acyclic graph (DAG), where V are tasks and there is an edge E from V[i] to V[i + 1] if and only if V[i]'s end time &le; V[i + 1]'s start time. From the DAG, every node on any path can be distributed to a machine. If we want to find the minimum number of machines we need, we have to minimize the number of paths such that no two paths share an endpoint, which is equivalent to the minimum edge cover problem in a bipartite graph. Let <strong>A</strong> = V and <strong>B</strong> = V be two disjoint and independent sets, edges connecting from A to B are corresponding to E. This will form a bipartite graph. Finding the maximum matching in bipartite graph is a well known problem which can be solved in O(|V|<sup>3</sup>). The number of unmatched points in A is the number of machines we need. Once we know the maximum matching, we can also get the minimum number of machines we need because maximum independent set = minimum edge cover = |V| - maximum matching in bipartite graph.<br /><br />
        To get the maximum cooling time, we are going to use binary search. We know that the cooling time affects how G looks like. If the cooling time is longer, |E| and matchings become less, hence the number of machines increases, vice versa. This solution has worse performance though.
      </div>
      <div id="MACHCOOL">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/MACHCOOL/" target="_blank">Link</a> | 
          Time: 0.3s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2019-05-19<br />
          Difficulty: 
          <i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Greedy</span><span class="tag">Binary Search</span><span class="tag">Ad-hoc</span>
        </div>
        <hr />
        There is a straightforward solution with greedy insight.
        <h3>Approach 1: Always choose i + M machine (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL_1.cpp" target="_blank">Solution Link</a>)</h3>
        Let's sort tasks <strong>T</strong> by start time in an ascending order. To optimize the distribution of M machines, we should not put the same machine on consecutive tasks. Consider this situation: Let |T| = 4 and M = 2. If we assign the first machine to {T[0], T[1]}, the second the machine to {T[2]}, this answer is then T[1] - T[0]. If only {T[1]} is assigned to the second machine, the answer is T[2] - T[0]. Note that the tasks are sorted by the start time, hence T[2] &ge; T[1] &ge; T[0]. If we add one more task T[3], obviously min(T[2] - T[0], T[3] - T[1]) &ge; min(T[1] - T[0], T[3] - T[2]). This is also true for arbitrary N &gt; 0. Therefore, the best approach is to make the number of tasks assigned to each machine and its interval evenly distributed. It helps avoid the result from being pulled down by a significantly small interval of some other machines. That's why we better assign T[i] to the i modulo M machine individually, and the answer is min(86400, T[i + M] - T[i]), where i + M &lt; N. We reach the solution in O(N * logN).
        <h3>Approach 2: Binary search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL_2.cpp" target="_blank">Solution Link</a>)</h3>
        This idea is still the same as before based on sorted <strong>T</strong>, but we will be using binary search. Let <strong>L</strong>  = 0 and <strong>R</strong> = 86400 be the search range. During each search, the median <strong>MID</strong> will be our guess. Looping through T to see whether T[i + M] - T[i] &ge; MID. If so, it means the maximum cooling time &ge; MID, so we can assume MID is our answer and increase L for a larger answer. Otherwise, MID is not a valid answer so we have to reduce the range by reducing R. The time complexity of this approach is still (N * logN).
      </div>
      <div id="TLPNGEM">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/TLPNGEM/" target="_blank">Link</a> | 
          Time: 0.6s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-11-08<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Queue</span><span class="tag">Stack</span>
        </div>
        <hr />
        This problem can be solved by dynamic programming in O(N). Since we can only move right, we have to collect all the gems sequentially.
        <h3>Approach 1: Dynamic programming (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TLPNGEM.cpp" target="_blank">Solution Link</a>)</h3>
        Let <strong>T</strong> and <strong>G</strong> be the positions of teleporters and gems, respectively. The maximum number of moves is G[|G| - 1] as we can only move one unit at a time. For the minimum number of moves, it depends on the optimal results in the last unit or previous three teleporters. Donate <strong>f[p]</strong> as the minimum number of moves from 0 to S[p]. Initially, p[0] = 0 because we are already at position 0, and for p &ge; 1 in the worst case, f[p] = f[p - 1] + 1 = p. For each position, our first step is to check whether S[p] belongs to "@" (teleporter) or "*" (gem).<br /><br />
        Let <strong>X</strong> and <strong>Y</strong> point to the current index of T and G respectively. If S[p] = "*", we simply collect the gem and increase Y by 1. If S[p] = "@", we have to update the minimum number of moves to reach the next 3 teleporters. So, let's update f[T[X] + i], where 1 &le; i &le; 3 and X + i &lt; |T|. For each i, we may consider either being transferred from the current teleporter T[X] or not being transferred. Therefore, f[T[X] + i] = min(f[T[X] + i], f[p] + 3). The final answer is f[G[|G| - 1]]. Since the maximum number of teleporters being transferred to is 3, we can also use double-ended queue (Deque) or three pointers to solve this problem based on the same idea of dynamic programming.
      </div>
      <div id="LNTILING">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/LNTILING/" target="_blank">Link</a> | 
          Time: 0.7s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-10-25<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Depth-first Search</span><span class="tag">Bitmasking</span><span class="tag">Simulation</span><span class="tag">Implementation</span>
        </div>
        <hr />
        Trying all possibilities costs O(2<sup>N</sup> * N!), instead we will use different techniques to speed up the solution.
        <h3>Approach 1: Depth first search with bitmasking and memoization (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/LNTILING.cpp" target="_blank">Solution Link</a>)</h3>
        Flattening all M * K tiles, we will be simulating putting different flatted tiles <strong>T</strong> into gap <strong>G</strong>. Define <strong>fit(p, T[i])</strong> as whether T[i] can fit in G if we put T[i] at G[p]. A quick check for failure case is that |T[i]| + p &gt; |G|. Otherwise, we can check it by rotating T[i] clockwise or counterclockwise by 90 degrees. Instead of trying all possible placments, we can achieve the same goal by comparing the turn of two adjacent units of both T[i] and G. The turn function returns the difference between two turns by encoding a direction into a number {'L': 0, 'D': 1, 'R': 2, 'U': 3}. To avoid result underflow and overflow, plus 4 and modulo 4 are taken, where 4 is the number of possible turns. The result will always be either 0 (go straight), 1 (turn left 90 degrees) or 3 (turn right 90 degrees), and never be 2 (turn 180 degrees) because it means two units are overlapped. From G's head, we compare turn(T[i][j], T[i][j + 1]) with turn(G[p + j], G[p + j + 1]), where 1 &le; j &lt; |T[i]| - 1. Similary, from G's tail, we compare turn(T[i][j], T[i][j - 1]) with turn(G[p + |T[i]| - j], G[p + |T[i]| - j + 1]), where 1 &gt; j &ge; |T[i]| - 1. Note that we ignore the first unit of T[i] as it will always fit in G regardless of rotation. Therefore, fit(p, T[i]) is true if turn(T) = turn(G) or turn(T') = turn(G').
        <br /><br />
        So what is the proper subset of T and permutation to fit in the entire G? Let's try to generate those subsets and permutations by depth first search (DFS) and bitmasking. Every bit represents a particular T[i]. Define <strong>f(mask, p)</strong> as whether the subset of T excluded from mask can be permuted to fit in G[p]. An unset i-th bit means T[i] is unused, we can check if it can fit in G[p] by invoking fit(p, T[i]). If so, we will discard it by setting the i-th bit and recursively check the next available tile by f(mask | i-th bit, p + |T[i]|). If not, the current permutation is no longer valid so we can stop exploring the remaining tiles. One observation is that this process includes a lot of overlapping computation because most of those masks being passed is duplicate. By memoizing the results of a particular mask using three states: {-1 (unsolved), 0 (unfit), 1 (fit)}, where cache[mask] = 1 when p = |G|, it improves execution time. Every submask is a subproblem of mask, so when cache[mask] = X, cache[any submask of mask] = X, where X &sub; {0, 1}.
        <br /><br />
        With the help of bitmasking and memoization, plus some pruning, we discard all invalid permutations as early as possible to make the recursion tree shorter and speed up our solution. This is also called bitmask dynamic programming.
      </div>
      <div id="GIFTARNG">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/GIFTARNG/" target="_blank">Link</a> | 
          Time: 0.4s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-07-26<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span>
        </div>
        <hr />
       Instead of an O(6<sup>N</sup>) naive solution which is to try every combination, an O(N) dynamic programming solution will be described here.
        <h3>Approach 1: Dynamic programming (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/GIFTARNG.cpp" target="_blank">Solution Link</a>)</h3>
        For a particular i-th gift box, consider all 6 possible rotations <strong>R[j][i]</strong> for 3 unduplicated surfaces: {W, D}, {H, D}, {W, H}, where 0 &le; j &lt; 6. Let <strong>f[i][j]</strong> be the current maximum visible area we can obtain from gift[0] to gift[i] in which we place gift[i] as R[i][j]. Consider the following transition states for all j:
        <ul>
          <li>
            <strong>When i = 0, it is just first gif box's total surface area excluding the bottom:</strong><br />
            Hence, f[0][j] = R[0][j].W * R[0][j].D * 2 + R[0][j].H * R[0][j].D * 2 + R[0][j].W * R[0][j].H
          </li>
          <li>
            <strong>When i &ge; 1, combining the R[i] with f[i - 1], resulting in 36 combinations:</strong><br />
            Note that one side of {H, D} touches gift[i - 1], there are three cases when we place R[i][j] centrally horizontally behind R[i - 1][j]:
            <ol>
              <li>H[i] &le; H[i - 1] and D[i] &le; D[i - 1]: The total area of {H, D} is not affected.</li>
              <li>H[i] &gt; H[i - 1] and D[i] &gt; D[i - 1]: It completely wraps R[i - 1][j].</li>
              <li>H[i] &gt; H[i - 1] or D[i] &gt; D[i - 1], not both: It partially wraps R[i - 1][j] horizontally or vertically.</li>
            </ol>
            Hence, f[i][j] = max(f[i - 1][j] + R[i][j].W * R[i][j].D * 2 + R[i][j].W * R[i][j].H + extra area from case 2, 3)
          </li>
        </ul>
        To reduce the space complexity, since we just need f[i - 1][j] to compute f[i][j], there is no need to store all states prior to i - 1. The answer is max(f[N - 1][j]). The overall time complexity becomes O(36 * (N - 1) + 6) = O(N).
      </div>
      <div id="TRIBT">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/TRIBT/" target="_blank">Link</a> | 
          Time: 1s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-04-13<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Tree</span><span class="tag">Depth-first Search</span>
        </div>
        <hr />
        Note that in a binary tree, the base of an isosceles triangle is either on the left, right or bottom, and at most two of them can be formed by a node at the same time.
        <h3>Approach 1: Depth first search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TRIBT.cpp" target="_blank">Solution Link</a>)</h3>
         We treat a particular node[i] as a vertex of two edges with equal length and check which two types of triangle can be formed by counting <strong>DC<sub>L</sub>[i]</strong> and <strong>DC<sub>R</sub>[i]</strong>: the depth from node[i] to the leftmost leaf and rightmost leaf respectively, as well as <strong>DP<sub>L</sub>[i]</strong> and <strong>DP<sub>R</sub>[i]</strong>: the depth from node[i] to the highest ancestor where the side between node[i] and its parent and the side between a particular node and its parent differ. Donate <strong>dfs(i, DP<sub>L</sub>[i], DP<sub>R</sub>[i])</strong> as a post-order DFS funtion which returns {DC<sub>L</sub>[i], DC<sub>R</sub>[i]} and update the answer on the fly. When node[i] is a leaf, it has no child so the function returns {1, 1}, otherwise, as in post-order traversal we start from the leftmost leaf, its results are always larger than its child's by 1. DP[i] being passed to the function does not affect the results, but it does affect the answer. A node only has at most one parent, meaning DP<sub>L</sub>[i] and DP<sub>R</sub>[i] cannot co-exist and one of them must be 0. As for root, it has no parent hence we start from dfs(0, 0, 0). Then we have DC<sub>L</sub>[i] = dfs(node[i]'s left child, DP<sub>L</sub>[node[i]'s parent] + 1, 0)[0] + 1 and DC<sub>R</sub>[i] = dfs(node[i]'s right child, 0, DP<sub>R</sub>[node[i]'s parent] + 1)[1] + 1.<br /><br />
         Once we know both DP and DC, the maximum area of the triangle is then determined by min(length of two sides), which can be splitted into equal number of triangles. The answer of node[i] is min(DC<sub>L</sub>[i], DC<sub>R</sub>[i]) + min(DC<sub>L</sub>[i], DP<sub>R</sub>[i]) + min(DC<sub>R</sub>[i], DP<sub>L</sub>[i]), and we add all nodes' answer up during tree traversal in O(N).<br /><br />
         <a href="https://www.geeksforgeeks.org/number-of-isosceles-triangles-in-a-binary-tree/" target="_blank">An article about this problem</a> published on GeeksforGeeks in 2022, there are diagrams to help you understand.
      </div>
      <div id="SMTOILET">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/SMTOILET/" target="_blank">Link</a> | 
          Time: 0.45s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-04-11<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Prefix Sum</span><span class="tag">Basic Math</span><span class="tag">Binary Search</span><span class="tag">Simulation</span><span class="tag">Two pointers</span><span class="tag">Ad-hoc</span>
        </div>
        <hr />
        <h3>Approach 1: Prefix sum and two pointers (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/SMTOILET_1.cpp" target="_blank">Solution Link</a>)</h3>
        Using prefix sum <strong>SUM</strong>, we can calculate the accumulative amount of ordors <strong>ACCUM</strong> at i-th second, where ACCUM[0] = O[0] and ACCUM[i] = ACCUM[i - 1] + SUM[i]. Once ACCUM[i] &ge; M. we know at either i or i + 1 second, the absolute difference between the current amount of odors and the tolerance will be minimized. In case M &gt; ACCUM[N - 1], we can stand ACCUM[N - 1] in N seconds, plus the extra amount of odors divided by SUM[N - 1].<br /><br />
        For the second part, we can use two pointers to find out the longest portion of consecutive available cubicles by maintaining the leftmost and rightmost index of current portion. The optimal position is within the longest portion so far. Since the chosen position should be as middle in that portion as possible and as close to the entrance as possible, if there are multiple portions with the same length, we can determine the best position based on the distance from i to the entrance. In case S[i] = 'x' we can move to next cubicle because that cubicle is already occupied. It produces an O(|S|<sup>2</sup>) solution.
        <h3>Approach 2: Binary search and two pointers (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/SMTOILET_2.cpp" target="_blank">Solution Link</a>)</h3>
        ACCUM is strictly increasing, so we can use binary search. Let <strong>L</strong> and <strong>R</strong> be the search range. We know that we need at least 1 second to wait for the release of odors, hence L = 1. Besides, we can stand all the amount of odors in the first N seconds, plus extra amount of odors divided by SUM[N - 1], hence R = N + max(M - ACCUM[N - 1], 0) / SUM[N - 1] + 1. For every median <strong>MID</strong>, we will be calculating the accumulative amount of odors at MID second in O(N) by &sum;<sub>i=0</sub><sup>min(N - 1, MID - 1)</sup>O[i] * (MID - i). It the result &lt; M, it means at MID seconds, the accumulative amount of odors is less than M, and we can stand more so we increase L. If the result &gt; M, it is not a valid answer so we narrow down R. It produces an O(N * logR) solution.<br /><br />
        As for the second part of the problem, we use the same approach: Two pointers, so please refer to the second part of approach 1.
      </div>
      <div id="MAPEXC">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/MAPEXC/" target="_blank">Link</a> | 
          Time: 0.6s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-03-29<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Graph</span><span class="tag">Breadth-first Search</span><span class="tag">Shortest Path</span>
        </div>
        <hr />
        Only moving from '.' to '.' will increase no cost, otherwise the cost is increased by 1. It becomes a single-source weighted shortest path problem in a grid, where the distance is either 0 or 1, hence we can use breadth first search (BFS).
        <h3>Approach 1: Breadth first search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MAPEXC_1.cpp" target="_blank">Solution Link</a>)</h3>
        Given a grid graph <strong>G</strong>, let's traverse G from the source S horizontally or vertically using BFS in O(N * M). Define <strong>C[i][j]</strong> as the minimum cost of exploring from S to G[i][j]. Initially, C[S<sub>i</sub>][S<sub>j</sub>] = 0 and for all other C[i][j] = -1, meaning that we have not visited any cells yet except the source. On each move to adjacent valid cells, consider the following conditions:
        <ul>
          <li>
            <strong>Cost is still the same: C[adj_i][adj_j] = C[i][j]</strong><br />
            Moving from tunnel to tunnel costs nothing. Update the cost if and only if we have not visited G[adj_i][adj_j] or C[i][j] is cheaper.<br />
          </li>
          <li>
            <strong>Cost is increased: C[adj_i][adj_j] = C[i][j] + 1</strong><br />
            Entering or leaving tunnel does cost. Update the cost if and only if we have not visited visited G[adj_i][adj_j] or C[i][j] + 1 is cheaper.
          </li>
        </ul>
        Once we know the cost matrix, the answer is simply printing something based on the matrix.
      </div>
      <div id="TRFPLN">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/TRFPLN/" target="_blank">Link</a> | 
          Time: 0.04s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-03-27<br />
          Difficulty: 
          <i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Greedy</span><span class="tag">Divide &amp; Conquer</span><span class="tag">Prefix Sum</span><span class="tag">Brute Force</span>
        </div>
        <hr />
        An O(N<sup>2</sup>) solution is simple but inefficient, it can be improved by a divide and conquer approach.
        <h3>Approach 1: Range sum for each dimension (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TRFPLN.cpp" target="_blank">Solution Link</a>)</h3>
        Considering each dimension X, Y, Z independently. Let <strong>X'</strong> be sorted X, where X'[i] is a pair (sorted X[i], the original index in X). For a particular i-th point, we calculate the sum of distances from the westernmost point to all other points to the west of X'[i] using prefix sum <strong>SUM</strong>. Note that the results include overlapping distances. For those points to the east of X'[i], (X'[i] - X'[0]) * (N - 1 - i) are included wrongly. For those points to the west of X'[i], SUM[i] are also included wrongly. When calculating the sum of distances from X'[i] to all other points, we need to eliminate these overlapping results.<br /><br />
        Back to X[i], since we know the original index of X'[i] from the second element of X'[i], we are able to update the answer at the corresponding index of our resulting array <strong>DIST</strong>. Repeat the same procedure for Y and Z dimension, and those coordinates that minimize DIST<sub>X</sub>[i] + DIST<sub>Y</sub>[i] + DIST<sub>Z</sub>[i] are the answer. The time complexity of this solution is O(N * logN).
      </div>
    </div>
  </div>
  <hr />
  <footer></footer>
<script src="scripts/var.js"></script>
<script src="scripts/global.js"></script>
<script src="scripts/probs.js"></script>
</body>
</html>