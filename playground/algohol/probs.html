<html>
<head>
<title>My problems :: Algohol - Him0727 .NET</title>
<meta charset="utf-8">
<meta name="author" content="CHAN TAK HIM, him0727">
<meta name="description" content="Aloghol, a website about data structure and algorithm, powered by HIM0727 .NET" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="favicon.ico" type="image/x-icon" rel="shortcut icon" />
<link rel="stylesheet" href="styles/global.css">
<link rel="stylesheet" href="styles/probs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-11490216-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-11490216-2');
</script>
</head>
<body>
  <nav class="content">
    <span id="nav-left"></span>
    <span id="nav-right"></span>
  </nav>
  <div class="content" style="background-color: #EFF1FA;">
    <span style="color: #36AD16;">
      <svg class="bi bi-emoji-laughing" style="margin-top: 10px;" width="1em" height="1em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
        <path fill-rule="evenodd" d="M12.331 9.5a1 1 0 0 1 0 1A4.998 4.998 0 0 1 8 13a4.998 4.998 0 0 1-4.33-2.5A1 1 0 0 1 4.535 9h6.93a1 1 0 0 1 .866.5z"/>
        <path d="M7 6.5c0 .828-.448 0-1 0s-1 .828-1 0S5.448 5 6 5s1 .672 1 1.5zm4 0c0 .828-.448 0-1 0s-1 .828-1 0S9.448 5 10 5s1 .672 1 1.5z"/>
      </svg>
       - I am pleased to announce that my problem "LNTILING - Long Tiling" was selected as one of the ten problems in <a href="https://www.bubblecup.org/CompetitorsCorner/Problems" target="_blank">Round 2, Bubble Cup 13 (2020)</a>.
    </span>
  </div>
  <div class="content">
    <div id="left-menu" style="text-align: left">
      <ul>
        <li>TLPNGEM2 - Teleporters and Gems II</li>
        <li>ACRYM - Acronym</li>
        <li>KTRANS - K-transfer journey</li>
        <li>MACHCOOL2 - Machine Cooling II</li>
        <li>MACHCOOL - Machine Cooling</li>
        <li>TLPNGEM - Teleporters and Gems</li>
        <li>LNTILING - Long Tiling</li>
        <li>GIFTARNG - Gift Arrangement</li>
        <!--<li>PSHAPE - Plane Shapes Formation</li>-->
        <!--<li>PRIPYAT - Pripyat</li>-->
        <li>TRIBT - Triangle in Binary Tree</li>
        <li>SMTOILET - Smelly Toilets</li>
        <li>MAPEXC - Map Exploration Cost</li>
        <li>TRFPLN - Traffic Planning</li>
      </ul>
    </div>
    <div id="right-content"></div>
    <div style="display: none;">
      <div id="TLPNGEM2">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/TLPNGEM2/" target="_blank">Link</a> | 
          Time: 0.5s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2022-02-12<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Ad-hoc</span><span class="tag">Basic Math</span><span class="tag">Geometry</span>
        </div>
        <hr />
        Welcome to my first interactive problem! The constraints are not tight, we can actually guess the answer in just three tries.
        <h3>Approach 1: Some elementary algebra (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TLPNGEM2_1.cpp" target="_blank">Solution Link</a>)</h3>
        Let's start from upper right corner (10<sup>9</sup>, 10<sup>9</sup>) and lower right corner (10<sup>9</sup>, -10<sup>9</sup>), and then we obtain the manhattan distances <strong>D1</strong> and <strong>D2</strong> from these coordinates to our destination, where D1 + D2 &ge; 10<sup>9</sup> * 2. So, by calculating D1 + D2 - 10<sup>9</sup> * 2, we know the x-axis distance from the rightmost boundary to the x-coordinate of the destination, and subtracting that value from 10<sup>9</sup>, we know the x-coordinate of our target. Hence, X = 10<sup>9</sup> - (D1 + D2 - 10<sup>9</sup> * 2) / 2 = 10<sup>9</sup> * 2 - (D1 + D2) / 2. Once we know X, we can substitute X into D1 = |10<sup>9</sup> - X| + |10<sup>9</sup> - Y|, thus Y = 10<sup>9</sup> * 2 - X - D1. Note that this still works for any combination of positive and negative x and y coordinates, because 10<sup>9</sup> by 10<sup>9</sup> unit is the size of a quadrant in this problem and we start from the two rightmost coordinates, therefore our answer is relative to an origin (0, 0). If D1, D2 or both are too large, we receive negative value so the coordinate lies on either quadrant 2, 3 or 4. It means that we are able to guess the correct target in two guess, the last guess is for receiving a verdict. So this is a constant time solution running in O(1).
        <h3>Approach 2: Line-line intersection (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TLPNGEM2_2.cpp" target="_blank">Solution Link</a>)</h3>
        Same as above, we will be guessing the upper right corner and lower right corner to obtain <strong>D1</strong> and <strong>D2</strong>. Every coordinate that is D1 units away from (10<sup>9</sup>, 10<sup>9</sup>) is a potential target. Similarily, every coordinate that is D2 units away from (10<sup>9</sup>, -10<sup>9</sup>) is a potential target. Since in this problem we are calculating manhattan distance, those potential coordinates originated from D1 and D2 will form two straight lines respectively. The intersection point of these two lines is the destination. We can simply pick any two points on each of the two lines and find the intersection. Now it becomes a famous problem with a well kwown solution using determinants. For details, please read <a href="https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line" target="_blank">Line-line intersection page on Wikipedia</a>. Although this solution requires a slightly heavy implementation and computation, the time complexity is still O(1).
      </div>
      <div id="ACRYM">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/ACRYM/" target="_blank">Link</a> | 
          Time: 0.8s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2020-05-14<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Combinatorics</span><span class="tag">String</span><span class="tag">Prefix & Suffix</span><span class="tag">Subsequence</span>
        </div>
        <hr />
        If we draw a tree diagram for every possible combination, with a dummy root, we will find there are many overlapping subpaths. The performance can be improved by bottom-up dynamic programming.
        <h3>Approach 1: Dynamic Programming (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/ACRYM.cpp" target="_blank">Solution Link</a>)</h3>
        Let <strong>f[j]</strong> be the number of possible combinations of making S[0 ... j] using the prefixes from W[0] to W[i - 1], and <strong>f'[j]</strong> be the same but using the prefixes from W[0] to W[i]. We need the result of f[j] in order to get f '[j] because the order of words is fixed. For W[0], f[1 ... k] = 1 where k is the length of longest common prefix with S, otherwise 0. Then, consider the following transition states for W[i] where i &gt; 0:
        <ul>
          <li><strong>Step 1. Determine the base value by checking the type of W[i]</strong><br />
          If W[i] is conjuction and adposition, we can ignore it, hence f '[j] = f[j], otherwise f '[j] = 0.<br />
          </li>
          <li><strong>Step 2. Compare every prefix of W[i] with every suffix of every prefix of S</strong><br />
          Let <strong>P<sub>W</sub></strong> and <strong>P<sub>S</sub></strong> be the length of current prefix of W[i] and S respectively, where 1 &le; P<sub>W</sub> &le; min(|W[i]|, |S|) and P<sub>W</sub> &lt; P<sub>S</sub> &le; |S|. If the current prefix of W[i] is a suffix of the current prefix of S, it means W[i] is a valid candidate, but doesn't mean S[0 ... P<sub>W</sub> - 1] is contiguous considering any combination of prefixes from W[0] to W[i - 1], thus we want f[P<sub>S</sub> - P<sub>W</sub> - 1] &gt; 0. If both are satisfied, we get f '[P<sub>S</sub>] = f '[P<sub>S</sub>] + f[P<sub>S</sub> - P<sub>W</sub> - 1]. Note that if f '[j] = 0 for every j, we can immediately determine the answer is 0 without trying the remaining words because the result is not contiguous anymore.
          </li>
          <li><strong>Step 3. Swap f[j] with f '[j]</strong><br />
          Make use of f '[j] to compute the next f '[j], so f[j] = f '[j]
          </li>
        </ul>
        Our final answer is f[|S|]. Everything is bounded by |S|, so the time complexity is O(N * |S|<sup>2</sup>). Another way to think the problem: for each word, it forms a set with |W[i]| elements, containing all prefixes of W[i] (also empty string if it is conjunction or adposition), where its value is the prefix length. We have N sets and a bag with |S| capacity, we want to select one element from each set, such that the bag value is exactly |S| while satisfying the constraint that the selected element must be part of the suffix of current S. This is a variant of multiple-choice knapsack problem.
      </div>
      <div id="KTRANS">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/KTRANS/" target="_blank">Link</a> | 
          Time: 0.4s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2019-11-02<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Shortest Path</span>
        </div>
        <hr />
        We can view the shortest travel time as the shortest weighted path. Then this problem is clearly all-pairs constrained shortest path problem, the true way to go is to use a variant of Floyd-Warshall algorithm.
        <h3>Approach 1: Run Floyd-Warshall algorithm K times (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/KTRANS.cpp" target="_blank">Solution Link</a>)</h3>
        Given a directed graph <strong>G = (V, E)</strong> with weight W[i] for E[i] and the second constraint L[i] for V[i], where V donates cities, E donates flights and W donates travel time. Note that one of the constraints in this problem is that the amount of incoming accumulate flow for each directly connected pair of nodes is restricted, thus the following shortest path property is not necessarily true: A subpath of a shortest path is a shortest path. Thus, the resulting path(u, v) might not necessarily be path(u, k) + path(k, v). That's why should find the shortest path by doing K relexations for each vertex with a condition check on L[i].<br /><br />
        Define two distance matrices <strong>D'</strong> as the results of length K - 1 and <strong>D</strong> as the results of length K. We will be finding the shortest path for every (U, V) with length from 1 to K incrementally using previous K - 1 results. During each relaxation, for each (U, V), we treat U[i] as an intermediate vertex and test whether the shortest travel time from a particular city <strong>T</strong> to V[i] can be improved by passing through path(T, U[i], V[i]) while still satisfying the constraint D '[T][U[i]] &le; L(U[i], V[i]). Hence, if there is a path from T to V[i], then D[T][V[i]] = min(D '[T][U[i]] + W[i]). And at the end, swap D ' with D to let the next relaxation process make use of the current results. This solution requires K relaxations for each (U, V), hence can be run in O(K * |E| * |V|) = (|V| - 1) * |V| * (|V| - 1) * |V| = 6002500 iterations in the worse case.
      </div>
      <div id="MACHCOOL2">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/MACHCOOL2/" target="_blank">Link</a> | 
          Time: 0.5s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2019-05-29<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Graph</span><span class="tag">Greedy</span><span class="tag">Heap</span><span class="tag">Matching</span><span class="tag">Binary Search</span><span class="tag">Depth-first Search</span>
        </div>
        <hr />
        The requirements of this problem are similar to MACHCOOL, except for the duration of tasks and the number of machines. We have many ways to solve this problem.
        <h3>Approach 1: Min heap (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL2_1.cpp" target="_blank">Solution Link</a>)</h3>
        Since a task must wait for the preceding task to complete before it can proceed, we are only interested in max(D[i][j]) for T[i]. First we sort T by their start time and end time ascendingly. Then, we find out <strong>M</strong>, where M is the minimum number of machines we need. We want one machine to deal with as many tasks as possible, so we must assign T[i] to a machine as early as possible once its start time &ge; the end time of the latest task assigned to that machine. Otherwise, we need a new machine to hold that task. For T[i], by using min heap, we can get the earliest end time among T[0] to T[i - 1] in a constant time. If the start time of T[i] &ge; the top element of the heap, it means T[i] can be held by existing machines, then we pop the top element and check the next top element in the heap until T[i] has a conflict with it. Finally, the remaining elements of the heap are the end time of tasks which we need a new machine to handle. Thus, M is the heap size.<br /><br />
        To distribute them optimally, the idea is similar to the greedy approach mentioned in MACHCOOL. We consecutively distribute M machines as early as possible by pushing the first M tasks into an empty min heap. For the remaining N - M tasks, our goal is to maximize the gap between the start time of T[i] and the end time of the latest task assigned to any machine. Note that the top element in the heap is already the earliest end time of the task already assigned, hence the answer is min(start time of T[i] - top element in the heap) for each remaining task. The overall time complexity is O(N * logN). 
        <h3>Approach 2: Line sweep with binary search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL2_2.cpp" target="_blank">Solution Link</a>)</h3>
        We are going to binary search on the answer. But before, we need to know <strong>M</strong>, which is the minimum number of machines needed to handle all tasks. We use the same greedy insight with line sweep algorithm. Donate <strong>f(C)</strong> as the minimum number of machines needed to finish all tasks with C cooling time for each machine. This time We are going to flatten T into two pairs (start time, 1) and (start time + max(D[i][j]) + C, -1) and sort them ascendingly. Thus, we have 2 * N records. By loop through those records, we can recognize if it is the start time or end time by the second element of the pair. If the value is 1, we need a new machine to hold that task, otherwise an existing machine is released and can be used by another task. The maximum value during the iteration will be the answer of f(C). Obviously, f(0) gives us the minimum of machines we need. Let <strong>L</strong> and <strong>R</strong> be the search range, where L = 0 and R = 86400. During each search, if M &ge; f(MID), where MID is the median <strong>MID</strong> of L and R, it is a valid answer because M machines are enough to handle all the tasks with MID cooling time. Then we just set L to MID + 1 to =search for a larger answer. Otherwise, we need to decrease the cooling time hence R = MID - 1. This solution has the same time complexity as before.
        <h3>Approach 3: Maximum bipartite matching (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL2_3.cpp" target="_blank">Solution Link</a>)</h3>
        This problem can be modelled as a graph problem. Let <strong>G = (V, E)</strong> be a directed acyclic graph (DAG), where V are tasks and there is an edge E from V[i] to V[i + 1] if and only if the end time of V[i] &le; the start time of V[i + 1]. From the DAG, every node on any path can be distributed to a machine. If we want to find the minimum number of machines we need, we have to minimize the number of paths such that no two paths share an endpoint, which is equivalent to the minimum edge cover problem in a bipartite graph. Let <strong>A</strong> = V and <strong>B</strong> = V be two disjoint and independent sets, edges connecting from A to B are corresponding to E. This will form a bipartite graph. Finding the maximum matching in bipartite graph is a well known problem which can be solved in O(|V|<sup>3</sup>) = O(N<sup>3</sup>). The number of unmatched points in A is the number of machines we need. Once we know the maximum matching, we can also get the minimum number of machines we need because maximum independent set = minimum edge cover = |V| - maximum matching in bipartite graph.<br /><br />
        To get the maximum cooling time, we are going to do binary search. We know that the cooling time affects how G looks like. If the cooling time is longer, |E| and matchings become less, hence the number of machines increases, vice versa. This solution has worse performance though.
      </div>
      <div id="MACHCOOL">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/MACHCOOL/" target="_blank">Link</a> | 
          Time: 0.3s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2019-05-19<br />
          Difficulty: 
          <i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Greedy</span><span class="tag">Binary Search</span><span class="tag">Ad-hoc</span>
        </div>
        <hr />
        There is a straightforward solution with greedy insight.
        <h3>Approach 1: Always choose i + M machine (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL_1.cpp" target="_blank">Solution Link</a>)</h3>
        Let's sort the tasks <strong>T</strong> by the start time in an ascending order. To optimize the distribution of M machines, we should not put the same machine on consecutive tasks. Consider this situation: Let |T| = 4 and M = 2. If we assign the first machine to {T[0], T[1]}, the second the machine to {T[2]}, this answer is then T[1] - T[0]. If only {T[1]} is assigned to the second machine, the answer is T[2] - T[0]. Note that the tasks are sorted by the start time, hence T[2] &ge; T[1] &ge; T[0]. If we add one more task T[3], obviously min(T[2] - T[0], T[3] - T[1]) &ge; min(T[1] - T[0], T[3] - T[2]). This is also true for arbitrary N where N > 0. From the example, we know that the best approach to make the number of tasks assigned to each machine and its interval evenly distributed. It helps avoid the result from being pulled down by the especially small interval of some other machines. That's why we better assign T[i] to the i modulo M machine individually. To implement that, we can simply loop through T and min(86400, T[i + M] - T[i]), where i + M &lt; N, will be our answer. We reach the solution in O(N * logN).
        <h3>Approach 2: Binary search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MACHCOOL_2.cpp" target="_blank">Solution Link</a>)</h3>
        This idea is still the same as before, but we are going to binary search on the answer. Again, we sort <strong>T</strong> first. Let <strong>L</strong> and <strong>R</strong> be the search range, where L = 0 and R = 86400. During each search, we find the median <strong>MID</strong> of L and R, loop through T to see whether T[i + M] - T[i] &ge; MID. If it does, it means the maximum cooling time is greater than or equal to MID, so we can assume MID is our answer and set L to MID + 1 to search for a larger answer. Otherwise, MID is not a valid answer so we have to reduce the range by setting R = MID - 1. The time complexity of this approach is still (N * logN).
      </div>
      <div id="TLPNGEM">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/TLPNGEM/" target="_blank">Link</a> | 
          Time: 0.6s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-11-08<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Queue</span><span class="tag">Stack</span>
        </div>
        <hr />
        This problem can be solved by dynamic programming in O(N). Since we can only move right, we have to collect all the gems sequentially.
        <h3>Approach 1: Dynamic programming (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TLPNGEM.cpp" target="_blank">Solution Link</a>)</h3>
        Let <strong>T</strong> and <strong>G</strong> be the positions of teleporters and gems, respectively. The maximum number of moves is G[|G| - 1] as we can only move one unit at a time. For the minimum number of moves, it depends on the optimal results in the last unit or previous three teleporters. Donate <strong>f[p]</strong> as the minimum number of moves from 0 to S[p]. Initially, p[0] = 0 because we are already at position 0, and for p &ge; 1 in the worst case, f[p] = f[p - 1] + 1 = p. For each position, our first step is to check whether S[p] belongs to "@" (teleporter) or "*" (gem).<br /><br />
        Let <strong>X</strong> and <strong>Y</strong> point to the current index of T and G respectively. If S[p] = "*", we simply collect the gem and increase Y by 1. If S[p] = "@", we have to update the minimum number of moves to reach the next 3 teleporters. So, let's update f[T[X] + i], where 1 &le; i &le; 3 and X + i &lt; |T|. For each i, we may consider either being transferred from the current teleporter T[X] or not being transferred. Therefore, f[T[X] + i] = min(f[T[X] + i], f[p] + 3). Do not forget to increase X by 1. Finally, the answer is f[G[|G| - 1]]. Since the maximum number of teleporters being transferred to is 3, we can also use double-ended queue (Deque) and three pointers to solve this problem based on the same idea of dynamic programming.
      </div>
      <div id="LNTILING">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/LNTILING/" target="_blank">Link</a> | 
          Time: 0.7s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-10-25<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span><span class="tag">Depth-first Search</span><span class="tag">Bitmasking</span><span class="tag">Simulation</span><span class="tag">Implementation</span>
        </div>
        <hr />
        Trying all possibilities costs O(2<sup>N</sup> * N!), instead we will use different techniques to speed up the solution.
        <h3>Approach 1: Depth first search with bitmasking and memoization (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/LNTILING.cpp" target="_blank">Solution Link</a>)</h3>
        Flattening the distinct tile[i] into K[i] tiles will make thing easier, eventually we have M * K tiles. Let's us simulate putting different flatted tiles <strong>T</strong> into the gap <strong>G</strong>. We have to answer two questions: whether T[i] can fit in G at a particular position, and what is the proper subset of available tiles and its permutation to fit in the entire G?<br /><br />
        To answer the first question, we define <strong>g(p, T[i])</strong> to tell us whether T[i] can fit in G if we put T[i] at G[p]. One quick check to determine it cannot fit is that |T[i]| + p &gt; |G|. Otherwise, every time we can rotate T[i] 90 degrees from its head or tail, so we get 8 different placements in total. Instead of trying all possible placements, we can simply compare the turn of T[i][j] and T[i][j + 1] with the turn of G[p + j] and G[p + j + 1], where 1 &le; j &lt; |T[i]| - 1. Similarly, to check it with different placements rotated from the tail, we can compare the turn of T[i][j] and T[i][j - 1] with the turn of G[p + |T[i]| - j] and G[p + |T[i]| - j + 1], where 1 &lt; j &le; |T[i]| - 1. Note that we ignore the first unit of T[i] and G[p] because it will always fit in G regardless of its rotation. To compare the turn, we define a map <strong>TURN</strong> = {'L': 0, 'D': 1, 'R': 2, 'U': 3} to translate T[i]'s direction to a value. For each turn, it can be rotated by 90 degrees or go straight, so if we calculate the change of turn by (TURN[T[i][j]] - TURN[T[i][j + 1]] + 4) modulo 4, the result is always either 0 (go straight), 1 (turn left 90 degres) or 3 (turn right 90 degrees). It will never be 2 (turn 180 degrees) because it means two units are overlapped which causes a contradiction. To conclude, we can check from the head T[i][1] and G[p + 1] at a time using the j and j + 1 unit. If the turn of T[i] and the turn of G are both the same, it fits. Otherwise, we check reversely from the tail T[i][|T[i]| - 1] and G[p + 1].<br /><br />
        The solution of the second question is some kind of intelligent brute force, which we try all subsets <strong>S</strong> &sub; T and its permuatations to see if the tiles from S can fit in G. Those subsets and permutations can be generated on the fly using depth first search (DFS). To avoid from counting duplicate T, we use bitmasking to record which tiles are used to save memory consumption. Define <strong>f(m, p)</strong> to check whether the subset excluded from mask m can fit in G[p]. For every mask, if T[i] is not used yet and g(p, T[i]) returns true, it fits in G[p], then we set the i-th mask in m and recursively check the next tile by invoking f(m OR the i-th mask from right, p + |T[i]|). Note that if g(p, T[i]) returns false, the current permutation is no longer valid and we stop exploring the remaining tiles, which greatly reduces the number of permutations. However, this is still inefficient because we are repeatedly computing the overlapping subpropblems. By observaing those masks being passed to our DFS function, most of them are duplicate. We can cache the results of subproblems we already solved. Let <strong>C</strong> represent the state of a particular mask, where C[i] &sub; {-1 (unsolved), 0 (unfit), 1 (fit)}. At first, all states are -1. When p = |G|, we reach the tail of G and hence C[m] = 1. The state of previous m depends on the current m, therefore C[m<sub>0</sub>] = C[m<sub>1</sub>] = ... = C[m<sub>i</sub>]. If there exits C[m] = 1, C[any submasks of m] = 1, otherwise C[all masks] = 0 or C[any submasks of m] = 0. So, if C[m] &ne; -1, we can simply return the result to avoid from invoking DFS many times.<br /><br />
        With the help of bitmasking and memoization, plus some pruning, we discard all invalid permutations as early as possible to make the recursion tree shorter and speed up our solution. This is also called bitmask dynamic programming.
      </div>
      <div id="GIFTARNG">
        <div class="constraint">
          Problem statement: <a href="https://www.spoj.com/problems/GIFTARNG/" target="_blank">Link</a> | 
          Time: 0.4s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-07-26<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Dynamic Programming</span>
        </div>
        <hr />
       Instead of an O(6<sup>N</sup>) naive solution which is to try every combination, an O(N) dynamic programming solution will be described here.
        <h3>Approach 1: Dynamic programming (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/GIFTARNG.cpp" target="_blank">Solution Link</a>)</h3>
        For each gift box, consider three unduplicated surfaces of it: {W, D}, {H, D}, {W, H}, there are 6 possible rotations {W, D, H}, {W, H, D}, {D, W, H}, {D, H, W}, {H, W, D} and {H, D, W}. Let <strong>R[i][j]</strong> be the j-th rotation of gift[i], where 0 &le; j &lt; 6, and <strong>f[i][j]</strong> be the current maximum visible area we can obtain from gift[0] to gift[i] in which we place gift[i] as R[i][j]. Consider the following transition states for all j:
        <ul>
          <li>
            <strong>Base case: no previous gift box</strong><br />
            For the first gift box, it is simply the total surface area excluding the bottom.<br />
            Hence, f[0][j] = R[0][j].W * R[0][j].D * 2 + R[0][j].H * R[0][j].D * 2 + R[0][j].W * R[0][j].H
          </li>
          <li>
            <strong>For i &ge; 1, combine with gift[i - 1]'s results</strong><br />
            We will be combining the current 6 rotations with f[i - 1], resulting in 36 combinations. Note that {W, H} and {W, D} can always be added because they do not touch gift[i - 1]. But for {H, D}, imagine we place R[i][j] centrally behind R[i - 1][j], there are three cases:
            <ol>
              <li>H[i] &le; H[i - 1] and D[i] &le; D[i - 1]: The total area of {H, D} is not affected.</li>
              <li>H[i] &gt; H[i - 1] and D[i] &gt; D[i - 1]: It completely wraps R[i - 1][j].</li>
              <li>H[i] &gt; H[i - 1] or D[i] &gt; D[i - 1]: It partially wraps R[i - 1][j] (extra part of R[i - 1][j] is on top / left and right).</li>
            </ol>
            Hence, f[i][j] = max(f[i - 1][j] + R[i][j].W * R[i][j].D * 2 + R[i][j].W * R[i][j].H + extra area of R[i - 1][j] if any)
          </li>
        </ul>
        To reduce the space complexity, since we just need f[i - 1][j] to compute f[i][j], there is no need to store all states prior to i - 1. At the end, we have 6 different answers, representing the maximum of area upto gift[N - 2] plus R[N - 1][j]. So the answer is max(f[N - 1][j]). The overall time complexity becomes O(36 * (N - 1) + 6) = O(N).
      </div>
      <div id="TRIBT">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/TRIBT/" target="_blank">Link</a> | 
          Time: 1s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-04-13<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Tree</span><span class="tag">Depth-first Search</span>
        </div>
        <hr />
        Note that in a binary tree, the base of an isosceles triangle is either on the left, right or bottom, and at most two of them can be formed by a node at the same time.
        <h3>Approach 1: Depth first search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TRIBT.cpp" target="_blank">Solution Link</a>)</h3>
         For a particular node[i], we have its left child C<sub>L</sub>[i] and right child C<sub>R</sub>[i]. We want to know <strong>DC<sub>L</sub>[i]</strong> and <strong>DC<sub>R</sub>[i]</strong>: the depth from node[i] to the leftmost leaf and rightmost leaf respectively, and to know <strong>DP<sub>L</sub>[i]</strong> and <strong>DP<sub>R</sub>[i]</strong>: the depth from node[i] to the highest ancestor where the side between node[i] and its parent and the side between a particular node and its parent differ. For example, node[i] is its parent's left child, we want to know which ancestor of node[i] is closest and is its parent's right child. To compute DC, we don't have to know DP, but to compute the answer, we do. Hence let's define an in-order DFS function <strong>f(i, DP<sub>L</sub>[i], DP<sub>R</sub>[i])</strong> to return a pair of (DC<sub>L</sub>[i], DC<sub>R</sub>[i]) and update the answer on the fly. Starting from f(0, 0, 0), during the traversal, we treat node[i] as the vertex of the triangle so two edges with equal length are joint at there. For the base case of our function, when node[i] is a leaf, it has no child so the returned depth is 1. For DC<sub>L</sub>[i], C<sub>L</sub>[i] is the next vertex and we can only produce the triangle with base on the right and bottom. Similarly, for DC<sub>R</sub>[i], C<sub>R</sub>[i] is the next vertex as well, and we can only produce the triangle with base on the left and bottom. Now, DC<sub>L</sub>[i] = f(C<sub>L</sub>[i], P<sub>L</sub>[i] + 1, 0)'s first element and DC<sub>R</sub>[i] = f(C<sub>R</sub>[i], 0, P<sub>R</sub>[i] + 1)'s second element.<br /><br />
         Once we know both DP and DC, the maximum area of the isosceles triangle is then determined by the minimum length of two sides, which can also be splitted into the minimum length number of isosceles triangles. Hence, the answer of node[i] is min(DC<sub>L</sub>[i], DC<sub>R</sub>[i]) + min(DC<sub>L</sub>[i], DP<sub>R</sub>[i]) + min(DC<sub>R</sub>[i], DP<sub>L</sub>[i]). The total number of isosceles triangle is simply the sum of the answer of each node, and it is added up during the tree traversal recursively in O(N).<br /><br />
         Recently, I found there is <a href="https://www.geeksforgeeks.org/number-of-isosceles-triangles-in-a-binary-tree/" target="_blank">an article about this problem on GeeksforGeeks</a> published in 2022, just 4 years after the creation of this problem. I suggest to have a look if you find it difficult to understand the solution.
      </div>
      <div id="SMTOILET">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/SMTOILET/" target="_blank">Link</a> | 
          Time: 0.45s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-04-11<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Prefix Sum</span><span class="tag">Basic Math</span><span class="tag">Binary Search</span><span class="tag">Simulation</span><span class="tag">Two pointers</span><span class="tag">Ad-hoc</span>
        </div>
        <hr />
        <h3>Approach 1: Prefix sum and two pointers (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/SMTOILET_1.cpp" target="_blank">Solution Link</a>)</h3>
        Let <strong>ACCUM[i]</strong> be the accumulative amount of odors at i-th second, and <strong>SUM</strong> be the prefix sum of O. We know that ACCUM[i] is accumuated with the growth of time every second, hence ACCUM[i] = O[0] * (i + 1) + O[1] * i + ... + O[i] = ACCUM[i - 1] + SUM[i]. Once ACCUM[i] &ge; M, the answer is either i or i + 1 (not minus 1 because the index starts from 0), depending on which minimizes the absolute difference between the current amount of odors and the tolerance. In case M &gt; ACCUM[N - 1], we can stand the accumulative smell of N toilets in N seconds, plus the extra amount of odors divided by SUM[N - 1]. Therefore, the answer will be N + (M - ACCUM[N - 1]) / SUM[N - 1] w/o adding 1.<br /><br />
        For the second part of the problem, we can use two pointers by maintaining two indices to find out the longest portion of consecutive available cubicles. Let <strong>E</strong> be the index of entrance, <strong>L</strong> and <strong>R</strong> be the leftmost and rightmost index of current portion. If it is the longest portion so far, the optimal position is within the current portion. Since the chosen position should be as middle in that portion as possible and as close to E as possible, if there are multiple portions with the same length, we can determine the best position based on the distance from i to E. In case S[i] = 'x' we can move to next cubicle because that cubicle is already occupied. This part is done in O(|S|<sup>2</sup>), we can improve it to O(|S|) by setting i to R + 1, but it requires us to deal with two cases when the length is even: i &lt; E and i &gt; E.
        <h3>Approach 2: Binary search and two pointers (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/SMTOILET_2.cpp" target="_blank">Solution Link</a>)</h3>
        ACCUM is strictly increasing, so we can use binary search. Let <strong>L</strong> and <strong>R</strong> be the search range. We know that we need at least 1 second to wait for the release of odors, hence L = 1. Besides, we can stand all the amount of odors in the first N seconds, plus extra amount of odors divided by SUM[N - 1], hence R = N + max(M - ACCUM[N - 1], 0) / SUM[N - 1] + 1. During each search, by determining the median <strong>MID</strong> between L and R, we are going to calculating the accumulative amount of odors at MID seconds by <strong>RES</strong> = &sum;<sub>i=0</sub><sup>min(N - 1, MID - 1)</sup>O[i] * (MID - i). If RES &lt; M, it means at MID seconds, the accumulative amount of odors is less than M, and we can stand more so L = MID + 1. If RES = M, it is probably our answer. If RES &gt; M, it is definitly not a valid answer so R = MID. Finally the answer is either R or R + 1. By searching logR times, we perform an O(N) computation for each each, it produces an O(N * logR) solution.<br /><br />
        As for the second part of the problem, we use the same approach: Two pointers, so please refer to the second part of approach 1.
      </div>
      <div id="MAPEXC">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/MAPEXC/" target="_blank">Link</a> | 
          Time: 0.6s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-03-29<br />
          Difficulty: 
          <i class="fa fa-star"></i><i class="fa fa-star"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Graph</span><span class="tag">Breadth-first Search</span><span class="tag">Shortest Path</span>
        </div>
        <hr />
        Only moving from '.' to '.' will increase no cost, otherwise the cost is increased by 1. It becomes a single-source weighted shortest path problem in a grid, where the distance is either 0 or 1, hence we can use breadth first search (BFS).
        <h3>Approach 1: Breadth first search (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/MAPEXC_1.cpp" target="_blank">Solution Link</a>)</h3>
        Given a grid graph <strong>G</strong>, let's traverse G from the source S horizontally or vertically using BFS in O(N * M). Define <strong>C[i][j]</strong> as the minimum cost of exploring from S to G[i][j]. Initially, C[S<sub>i</sub>][S<sub>j</sub>] = 0 and for all other C[i][j] = -1, meaning that we have not visited any cells yet except the source. On each move to adjacent valid cells, consider the following conditions:
        <ul>
          <li>
            <strong>Cost is still the same: C[adj_i][adj_j] = C[i][j]</strong><br />
            When moving from tunnel to tunnel, we do not pay the cost. So, if we have not visited G[adj_i][adj_j] or C[i][j] is cheaper, we have to update the cost.<br />
          </li>
          <li>
            <strong>Cost is increased: C[adj_i][adj_j] = C[i][j] + 1</strong><br />
            When Entering or leaving tunnel, we must pay the cost. So, if we have not visited visited G[adj_i][adj_j] or C[i][j] + 1 is cheaper, we have to update the cost.
          </li>
        </ul>
        Once we know the cost matrix, the answer is simply printing something based on the matrix.
      </div>
      <div id="TRFPLN">
        <div class="constraint">
          Problem statement: <a href="http://www.spoj.com/problems/TRFPLN/" target="_blank">Link</a> | 
          Time: 0.04s per test file | 
          Source: 5000B | 
          Memory: 1536MB | 
          Languages: ALL<br />
          Added on 2018-03-27<br />
          Difficulty: 
          <i class="fa fa-star"></i>
          <i class="fa fa-star-half-o"></i>
          <i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><i class="fa fa-star-o"></i><br />
          <span class="tag">Greedy</span><span class="tag">Divide &amp; Conquer</span><span class="tag">Prefix Sum</span><span class="tag">Brute Force</span>
        </div>
        <hr />
        An O(N<sup>2</sup>) solution is simple but inefficient, it can be improved by a divide and conquer approach.
        <h3>Approach 1: Range sum for each dimension (<a href="https://github.com/him0727/Online-Judge-Solutions/blob/master/SPOJ/My_problems/TRFPLN.cpp" target="_blank">Solution Link</a>)</h3>
        Consider each dimension X, Y, Z independently. Let <strong>X'</strong> be sorted X, where X'[i] is a pair (sorted X[i], the original index in X). It means that X'[0] is the westernmost point. Consider the prefix sum <strong>SUM</strong> of X', SUM[i] is the sum of distances from X'[0] to all other points to the west of X'[i] (inclusive). However, our goal is to calculate the sum of distances from X'[i] to all other points, instead of starting from X'[0], so SUM will give us overlapping distances. For those points to the east of X'[i], (X'[i] - X'[0]) * (N - 1 - i) are included wrongly. For those points to the west of X'[i], SUM[i] are also included wrongly. So, we need to eliminate the overlapping distances.<br /><br />
        However, it still does not answer the question, which is asking for X[i], not X'[i]. Thanks to the second element of X'[i], we know the original index of X'[i] in X. We will update the answer for the corresponding index of <strong>DIST</strong>, in this case, it is DIST[X'[i]'s second element]. Do the same procedure for Y and Z dimension, and those coordinates that minimize DIST<sub>X</sub>[i] + DIST<sub>Y</sub>[i] + DIST<sub>Z</sub>[i] are the answer. The time complexity of this solution is O(N * logN).
      </div>
    </div>
  </div>
  <hr />
  <footer></footer>
<script src="scripts/var.js"></script>
<script src="scripts/global.js"></script>
<script src="scripts/probs.js"></script>
</body>
</html>